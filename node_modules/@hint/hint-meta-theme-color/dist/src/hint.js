"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const color_string_1 = require("color-string");
const utils_1 = require("@hint/utils");
const meta_1 = require("./meta");
const i18n_import_1 = require("./i18n.import");
const { normalizeString } = utils_1.misc;
class MetaThemeColorHint {
    constructor(context) {
        let bodyElementWasReached = false;
        let firstThemeColorMetaElement;
        const checkIfThemeColorMetaElementWasSpecified = (event) => {
            const { resource } = event;
            if (!firstThemeColorMetaElement) {
                context.report(resource, i18n_import_1.getMessage('metaElementNotSpecified', context.language));
            }
        };
        const isNotSupportedColorValue = (color, normalizedColorValue) => {
            const hexWithAlphaRegex = /^#([0-9a-fA-F]{4}){1,2}$/;
            return (color.model === 'rgb' &&
                hexWithAlphaRegex.test(normalizedColorValue) &&
                !utils_1.isSupported({ property: 'color', value: '#00000000' }, context.targetedBrowsers)) ||
                color.model === 'hwb';
        };
        const checkContentAttributeValue = (resource, element) => {
            const contentValue = element.getAttribute('content');
            const normalizedContentValue = normalizeString(contentValue, '');
            const color = color_string_1.get(normalizedContentValue);
            if (color === null) {
                const message = i18n_import_1.getMessage('metaElementInvalidContent', context.language, contentValue);
                context.report(resource, message, { element });
                return;
            }
            if (isNotSupportedColorValue(color, normalizedContentValue)) {
                const message = i18n_import_1.getMessage('metaElementUnsupported', context.language, contentValue);
                context.report(resource, message, { element });
            }
        };
        const checkNameAttributeValue = (resource, element) => {
            const nameAttributeValue = element.getAttribute('name');
            if (nameAttributeValue && nameAttributeValue !== nameAttributeValue.trim()) {
                const message = i18n_import_1.getMessage('metaElementInvalidName', context.language, nameAttributeValue);
                context.report(resource, message, { element });
            }
        };
        const validate = ({ element, resource }) => {
            if (normalizeString(element.getAttribute('name')) !== 'theme-color') {
                return;
            }
            if (firstThemeColorMetaElement) {
                context.report(resource, i18n_import_1.getMessage('metaElementDuplicated', context.language), { element });
                return;
            }
            firstThemeColorMetaElement = element;
            if (bodyElementWasReached) {
                context.report(resource, i18n_import_1.getMessage('metaElementInBody', context.language), { element });
                return;
            }
            checkNameAttributeValue(resource, element);
            checkContentAttributeValue(resource, element);
        };
        context.on('element::meta', validate);
        context.on('element::body', () => {
            bodyElementWasReached = true;
        });
        context.on('traverse::end', checkIfThemeColorMetaElementWasSpecified);
    }
}
MetaThemeColorHint.meta = meta_1.default;
exports.default = MetaThemeColorHint;
